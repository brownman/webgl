<script>
<%content_for :global do %>
//  var RELEASE = true;
  var heightMap;
  var _debug_ray = new Line([0,0,-1],[0,1,-1]);
  var _debug_axis = new Axis();
  var selectedCreature = null;
  var destination = null;
  var selectionQuad = null;

  /* TODO: seriously, move this to the Camera class. And add a dedicated test for it, too. */
  // Converts screen coordinates into a ray segment with one point at the NEAR plane and the other
  // at the FAR plane relative to the camera's current matrices.
  // Code adapted from gluUnproject(), found at http://www.opengl.org/wiki/GluProject_and_gluUnProject_code
  function unproject(winx, winy, winz)
  {
    if (!winx || !winy) { throw new Error("one or both of X / Y is missing"); }

    // winz is either 0 (near plane), 1 (far plane) or somewhere in between.
    // if it's not given a value we'll produce coords for both.
    if (typeof(winz) == "number") {
      winx = parseFloat(winx);
      winy = parseFloat(winy);
      winz = parseFloat(winz);
    
      var inf = [];
      var mm = world.camera.getMatrix(), pm = world.camera.getProjectionMatrix();
      var viewport = [0, 0, world.context.gl.viewportWidth, world.context.gl.viewportHeight];

      //Calculation for inverting a matrix, compute projection x modelview; then compute the inverse
      var m = pm.multiply(mm).inverse();

      // Transformation of normalized coordinates between -1 and 1
      inf[0]=(winx-viewport[0])/viewport[2]*2.0-1.0;
      inf[1]=(winy-viewport[1])/viewport[3]*2.0-1.0;
      inf[2]=2.0*winz-1.0;
      inf[3]=1.0;

      //Objects coordinates
      var out = m.multiply($V(inf)).elements;
      if(out[3]==0.0)
         return null;

      out[3]=1.0/out[3];
      return [out[0]*out[3], out[1]*out[3], out[2]*out[3]];
    }
    else
    {
      return [unproject(winx, winy, 0), unproject(winx, winy, 1)];
    }
  }

  function updateKeyboardInput()
  {
    logger.attempt("update keyboard input", function() {
      var rotation = 0;
      var translation = [0,0,0];
      var movement_speed = 1.5; // in GL units per second
      var rotation_speed = 0.5;
      var strafing_speed = 1.0;
        
      movement_speed *= 0.75; // because that's the delay between frames (via setInterval, above)
      rotation_speed *= 0.15; // in an offline app we'd calculate time elapsed between frames.
      strafing_speed *= 0.15;
        
      if (currentlyPressedKeys[38]) rotation += rotation_speed; // arrow up
      if (currentlyPressedKeys[40]) rotation -= rotation_speed; // arrow down
      if (currentlyPressedKeys[87]) translation[2] -= 1; // W
      if (currentlyPressedKeys[83]) translation[2] += 1; // S
      if (currentlyPressedKeys[65]) translation[0] -= 1; // A
      if (currentlyPressedKeys[68]) translation[0] += 1; // D
        
      world.camera.move(movement_speed, translation);
      var position = world.camera.getPosition(), view = world.camera.getView();
      // this condition pegs the camera rotation so the user can't rotate
      // to inappropriate views (below the terrain, upside down, etc.)
      // Keep in mind that this is a totally unacceptable technique if
      // the camera is to rotate in other directions (for instance, to look left).
      if ((rotation > 0 && view[1] <= -0.521 && view[2] >= -0.853) ||
          (rotation < 0 && view[1] >= -0.98  && view[2] <= -0.196))
      {
        world.camera.rotateView(rotation, 0, 0);

        // we need to project along the [y,z] view vector from the camera's position
        // some set focal distance. We can't just use the camera's distance from the origin
        // (which would be its current position) because that can change by camera movement,
        // which causes some very bizarre camera issues indeed.
        window.predefined_distance = window.predefined_distance || [75, 42];
        position[1] -= predefined_distance[0];
        position[2] -= predefined_distance[1];
        
        var theta = rotation;
        var y = predefined_distance[0], z = predefined_distance[1];
        predefined_distance[0] = y*Math.cos(theta) - z*Math.sin(theta);
        predefined_distance[1] = y*Math.sin(theta) + z*Math.cos(theta);
        
        position[1] += predefined_distance[0];
        position[2] += predefined_distance[1];
        world.camera.look();
      }
    });
  }
<%end%>

<%content_for :init do%>
  selectionQuad = new Quad(1,1);
  selectionQuad.orientation.setPosition(0,0,-10);
  selectionQuad.orientation.orient([0,1,0],[0,0,1],[1,0,0],[0,20,0]);
  selectionQuad.orientation.look();
  selectionQuad.mesh.texture = new Texture("/images/selection.png");
//  selectionQuad.shader = 'color_with_texture';

  world.camera.moveTo(35, 75, 42);
  world.camera.orient([0, -1, -0.2], [0, 0.2, -1]).look();

  _debug_axis.offset = [0,10,0];
  _debug_axis.scale = 3;

  // need to keep the debug ray separate from the world because
  // our current implementation of heightmap will reposition
  // the ray based on the surrounding terrain. This is suboptimal
  // and needs to be addressed in a more permanent way.
//  world.addObject(_debug_ray);
      
  setInterval(updateKeyboardInput, 30);
<%end%>

<%content_for :render do%>
  world.context.gl.disable(GL_BLEND);
  world.render();

  
  world.camera.look(world.context.gl);
  _debug_ray.render(world.context);

  if (selectedCreature)
  {
    // update quad position because the creature may have moved
    var pos = selectedCreature.orientation.getPosition();
    selectionQuad.orientation.setPosition(pos[0], pos[1]+selectedCreature.lowest()+1, pos[2]);

    world.context.gl.enable(GL_BLEND);
    world.context.gl.blendFunc(GL_SRC_ALPHA, GL_ONE);
    selectionQuad.render(world.context);
    _debug_axis.render(world.context);
    
    if (destination)
    {
      if (!selectedCreature.ai.isMoving())
        destination = null;
      else
      {
        selectionQuad.orientation.setPosition(destination[0], destination[1]+1, destination[2]);
        selectionQuad.render(world.context);
      }
    }
  }
<%end%>
        
<%content_for :mouse_pressed do%>
  var target = world.pick(mouse.x, mouse.y);
  if (target)
  {
    selectedCreature = target;
    destination = null;
    selectionQuad.setSize(selectedCreature.mesh.size_x, selectedCreature.mesh.size_z);
    _debug_axis.set(selectedCreature.orientation);
  }
  else
  {
    var ray = unproject(mouse.x, world.context.gl.viewportHeight - mouse.y);
    _debug_ray.set(ray[0], ray[1]);
                 
    // line-segment/triangle collision detection
    // this belongs...er...somewhere else. (am i really writing a coldet library now??)
    // adapted from: http://softsurfer.com/Archive/algorithm_0105/algorithm_0105.htm#intersect_RayTriangle%28%29
    function coldet_segm_tri(segm, tri, I) // coldet_segm_tri([[0,0], [1,0]], [[0,0,0], [0,1,0], [1,0,0]]);
    {
      var u = tri[1].minus(tri[0]);
      var v = tri[2].minus(tri[0]);
      var n =  u.cross(v);
      if (n[0] == 0 && n[1] == 0 && n[2] == 0) //triangle is degenerate
        return -1;                             // do not deal with this case
      
      var dir = segm[1].minus(segm[0]); // ray direction vector
      var w0 = segm[0].minus(tri[0]);
      var a = -(n.dot(w0));
      var b = n.dot(dir);
      if (Math.abs(b) < Math.EPSILON) // ray is parallel to triangle plane
        if (a == 0)                   // ray lies in triangle plane
          return 2;
        else return 0;                // ray disjoint from plane
      
      // get intersect point of ray with triangle plane
      var r = a / b;
      if (r < 0.0) // ray goes away from triangle
        return 0;   // => no intersect
      // for a ray, don't test r > 1.0
      if (r > 1.0)  // segment ends before triangle
        return 0;   // => no intersect
      
      I[0] = segm[0][0] + (dir[0]*r);
      I[1] = segm[0][1] + (dir[1]*r);
      I[2] = segm[0][2] + (dir[2]*r);
      
      // is I inside T?
      var uu, uv, vv, wu, wv, D;
      uu = u.dot(u);
      uv = u.dot(v);
      vv = v.dot(v);
      w = I.minus(tri[0]);
      wu = w.dot(u);
      wv = w.dot(v);
      D = uv * uv - uu * vv;
      
      // get and test parametric coords
      var s, t;
      s = (uv * wv - vv * wu) / D;
      if (s < 0.0 || s > 1.0)        // I is outside T
        return 0;
      t = (uv * wu - uu * wv) / D;
      if (t < 0.0 || (s + t) > 1.0)  // I is outside T
          return 0;
      
      return 1; // I is in T
    }
    
    heightMap = world.scene;
    var v0 = [heightMap.triangles[0], heightMap.triangles[1], heightMap.triangles[2]],
        v1 = [heightMap.triangles[3], heightMap.triangles[4], heightMap.triangles[5]],
        v2 = [];
    var candidates = [];
    var holder = [];
    var tri = [];
    var j;
    
    for (var i = 6; i < heightMap.triangles.length; i += 3)
    {
      for (j = 0; j < 3; j++)
      {
        if (i > 6)
        {
          v0[j] = v1[j];
          v1[j] = v2[j];
        }
        v2[j] = heightMap.triangles[i+j];
      }
      
      tri[0] = v0;
      tri[1] = v1;
      tri[2] = v2;
      if (coldet_segm_tri(ray, tri, holder) == 1)
      {
        candidates.push(holder);
        holder = [];
      }
    }
    
    // we should really take the closest candidate to the camera, instead of just the first one in the list.
    destination = candidates[0];
    if (selectedCreature)
    {
      selectedCreature.ai.moveTo(destination, function(creature) { creature.playAnimation("stand", true); });
      selectedCreature.playAnimation("run", true);
    }
  }
<%end%>
</script>

<p>
  The "Interface" demo combines the various other demos to produce a mock-up, would-be game interface. It's not an
  actual game, though I do hope to code a game in WebGL one day.
</p>
<p>
  Currently, this demo makes use of World, Camera, HeightMap, Texture, Context, Renderable, MD2.
</p>
<p>
  You can control the camera with W, S, A and D. Up and down arrows will change the camera's pitch.
</p>
<p>
  You can also click on a creature, and tell the creature where to move by clicking on a location on the field.
  This is still pretty buggy (and slow) and it still has a lot of room for improvement, but it does work.
</p>