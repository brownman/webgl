<script>
<%content_for :global do %>
  var heightMap;
  var _debug_ray = new Line([0,0,-1],[0,1,-1]);
  var selectedCreature = null;
  var selectionQuad = null;

  /* TODO: seriously, move this to the Camera class. */
  // Converts screen coordinates into a ray segment with one point at the NEAR plane and the other
  // at the FAR plane relative to the camera's current matrices.
  // Code adapted from gluUnproject(), found at http://www.opengl.org/wiki/GluProject_and_gluUnProject_code
  function unproject(winx, winy, winz)
  {
    if (!winx || !winy) { throw new Error("one or both of X / Y is missing"); }
    
    // winz is either 0 (near plane), 1 (far plane) or somewhere in between.
    // if it's not given a value we'll produce coords for both.
    if (typeof(winz) == "number") {
      var inf = [];
      var mm = world.camera.getMatrix(), pm = world.camera.getProjectionMatrix();
      var viewport = [0, 0, world.context.gl.viewportWidth, world.context.gl.viewportHeight];

      //Calculation for inverting a matrix, compute projection x modelview; then compute the inverse
      var A = pm.multiply(mm).inverse();

      // Transformation of normalized coordinates between -1 and 1
      inf[0]=(winx-viewport[0])/viewport[2]*2.0-1.0;
      inf[1]=(winy-viewport[1])/viewport[3]*2.0-1.0;
      inf[2]=2.0*winz-1.0;
      inf[3]=1.0;

      //Objects coordinates
      var out = A.multiply($V(inf)).elements;
      if(out[3]==0.0)
         return null;

      out[3]=1.0/out[3];
      return [out[0]*out[3], out[1]*out[3], out[2]*out[3]];
    }
    else
    {
      return [unproject(winx, winy, 0), unproject(winx, winy, 1)];
    }
  }

  function updateKeyboardInput()
  {
    logger.attempt("update keyboard input", function() {
      var rotation = 0;
      var translation = [0,0,0];
      var movement_speed = 1.5; // in GL units per second
      var rotation_speed = 0.5;
      var strafing_speed = 1.0;
        
      movement_speed *= 0.75; // because that's the delay between frames (via setInterval, above)
      rotation_speed *= 0.15; // in an offline app we'd calculate time elapsed between frames.
      strafing_speed *= 0.15;
        
      if (currentlyPressedKeys[38]) rotation += rotation_speed; // arrow up
      if (currentlyPressedKeys[40]) rotation -= rotation_speed; // arrow down
      if (currentlyPressedKeys[87]) translation[2] -= 1; // W
      if (currentlyPressedKeys[83]) translation[2] += 1; // S
      if (currentlyPressedKeys[65]) translation[0] -= 1; // A
      if (currentlyPressedKeys[68]) translation[0] += 1; // D
        
      world.camera.move(movement_speed, translation);
      var position = world.camera.getPosition(), view = world.camera.getView();
      // this condition pegs the camera rotation so the user can't rotate
      // to inappropriate views (below the terrain, upside down, etc.)
      // Keep in mind that this is a totally unacceptable technique if
      // the camera is to rotate in other directions (for instance, to look left).
      if ((rotation > 0 && view[1] <= -0.521 && view[2] >= -0.853) ||
          (rotation < 0 && view[1] >= -0.98  && view[2] <= -0.196))
      {
        world.camera.rotateView(rotation, 0, 0);

        // we need to project along the [y,z] view vector from the camera's position
        // some set focal distance. We can't just use the camera's distance from the origin
        // (which would be its current position) because that can change by camera movement,
        // which causes some very bizarre camera issues indeed.
        window.predefined_distance = window.predefined_distance || [75, 42];
        position[1] -= predefined_distance[0];
        position[2] -= predefined_distance[1];
        
        var theta = rotation;
        var y = predefined_distance[0], z = predefined_distance[1];
        predefined_distance[0] = y*Math.cos(theta) - z*Math.sin(theta);
        predefined_distance[1] = y*Math.sin(theta) + z*Math.cos(theta);
        
        position[1] += predefined_distance[0];
        position[2] += predefined_distance[1];
        world.camera.look();
      }
    });
  }
<%end%>

<%content_for :init do%>
  selectionQuad = new Quad(1,1);
  selectionQuad.orientation.setPosition(0,0,-10);
  selectionQuad.orientation.orient([0,1,0],[0,0,1],[1,0,0],[0,20,0]);
  selectionQuad.orientation.look();
  selectionQuad.texture = new Texture("/images/selection.png");
//  selectionQuad.shader = 'color_with_texture';

  world.camera.moveTo(35, 75, 42);
  world.camera.orient([0, -1, -0.2], [0, 0.2, -1]).look();

  world.addObject(_debug_ray);
      
  setInterval(updateKeyboardInput, 30);
<%end%>

<%content_for :render do%>
  world.context.gl.disable(GL_BLEND);
  world.render();

//  _debug_ray.render(world.context);

  if (selectedCreature)
  {
    // update quad position because the creature may have moved
//    var pos = selectedCreature.orientation.getPosition();
//    selectionQuad.orientation.setPosition(pos[0], pos[1]+selectedCreature.lowest_point+1, pos[2]);

    world.context.gl.enable(GL_BLEND);
    world.context.gl.blendFunc(GL_SRC_ALPHA, GL_ONE);
    world.camera.look(world.context.gl);
    selectionQuad.render(world.context);
  }
<%end%>
        
<%content_for :mouse_pressed do%>
  var target = world.pick(mouse.x, mouse.y);
  if (target)
  {
    selectedCreature = target;
    selectionQuad.setSize(selectedCreature.size_x, selectedCreature.size_z);
  }
  else
  {
    var result = unproject(mouse.x, mouse.y);
    logger.info(result.toSource());
  }
<%end%>
</script>

<p>
  The "Interface" demo combines the various other demos to produce a mock-up, would-be game interface. It's not an
  actual game, though I do hope to code a game in WebGL one day.
</p>
<p>
  Currently, this demo makes use of World, Camera, HeightMap and Texture.
</p>
<p>
  You can control the camera with W, S, A and D.
</p>
