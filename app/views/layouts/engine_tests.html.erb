<!DOCTYPE html>
<html>
<head>
  <title>RailsGame</title>
  <base href="http://localhost/~colin/rails-game/" />
  <%= stylesheet_link_tag :all %>
  <%= javascript_include_tag :defaults %>
  <%= csrf_meta_tag %>
  <%=yield :head%>
  <script type="text/javascript" src="/javascripts/sylvester.js"></script>
  <script type="text/javascript" src="/javascripts/sylvester-ext.js"></script>
  <script type="text/javascript" src="/javascripts/gl-utils.js"></script>
  <script type="text/javascript" src="/javascripts/webgl.js"></script>
  <script type="text/javascript" src="/javascripts/engine/core.js"></script>
  <%dependencies.each do |fi| %>
    <%=javascript_include_tag fi%>
  <%end%>
  
  <%shaders.values.each do |shader|%>
    <script id="<%=shader.name%>-fs" type="x-shader/x-fragment">
      <%=shader.fragment_source%>
    </script>
    <script id="<%=shader.name%>-vs" type="x-shader/x-vertex">
      <%=shader.vertex_source%>
    </script>
  <%end%>
  
  <script type="text/javascript">
    var frame_count = 0;
    
    <%=yield :global%>
    
    function initShaders() {
      <%shaders.values.each do |shader|%>
        var fragmentShader = getShader(gl, "<%=shader.name%>-fs");
        var vertexShader = getShader(gl, "<%=shader.name%>-vs");
    
        var shaderProgram = shaders['<%=shader.name%>'] = gl.createProgram();
        gl.attachShader(shaderProgram, vertexShader);
        gl.attachShader(shaderProgram, fragmentShader);
        gl.linkProgram(shaderProgram);
    
        if (!gl.getProgramParameter(shaderProgram, gl.LINK_STATUS)) {
          alert("Could not initialise shader: <%=shader.name%>");
        }
    
        gl.useProgram(shaderProgram);
    
        function storeAttrib(name, shaderName)
        {
          var result = gl.getAttribLocation(shaderProgram, shaderName);
          if (result != -1)
          {
            shaderProgram.attributes = shaderProgram.attributes || [];
            shaderProgram.attributes.push(name);
            shaderProgram[name] = result;
          }
        }
      
        storeAttrib('vertexPositionAttribute', 'aVertexPosition');
        storeAttrib('vertexColorAttribute', 'aVertexColor');
        storeAttrib('textureCoordAttribute', 'aTextureCoord');
      
        shaderProgram.pMatrixUniform = gl.getUniformLocation(shaderProgram, "uPMatrix");
        shaderProgram.mvMatrixUniform = gl.getUniformLocation(shaderProgram, "uMVMatrix");
        shaderProgram.samplers = [];
        for (var i = 0; i < 32; i++) shaderProgram.samplers[i] = gl.getUniformLocation(shaderProgram, "textures["+i+"]");
        checkGLError();
      <%end%>
    }
  
  
    function drawScene() {
      if (drawScene.blocking) return;
      try {
        activeShader = null; // Shader seems to be lost between passes - TODO see if this is WebGL's fault or mine!
        useShader('color_without_texture');
        
        frame_count += 1;
  
        gl.viewport(0, 0, gl.viewportWidth, gl.viewportHeight);
        gl.clear(gl.COLOR_BUFFER_BIT | gl.DEPTH_BUFFER_BIT);
        
        perspective(45, gl.viewportWidth / gl.viewportHeight, 0.1, 100.0);
        loadIdentity();
    
        <%=yield :render%>
        checkGLError();
      } catch(e) {
        alert(e);
        drawScene.blocking = true;
        throw new Error(e.toString());
      }
    }
  
    function webGLStart() {
      logger.level = Logger.ERROR;
      if ($('logger')) $('logger').update(logger);
      
      var canvas = document.getElementById("canvas");
      
      canvas.onclick = canvas_clicked;
      canvas.onmousemove = mouse_moved;
      canvas.onmouseover = mouse_over;
      canvas.onmouseout  = mouse_out;
      canvas.onmousedown = mouse_down;
      canvas.onmouseup   = mouse_up;
      
      initGL(canvas);
      initShaders();
      initializationComplete();
  
      gl.clearColor(0.0, 0.0, 0.0, 1.0);
      gl.clearDepth(1.0);
      gl.enable(gl.DEPTH_TEST);
      gl.depthFunc(gl.LEQUAL);
      
      checkGLError();
      
      <%=yield :init%>
      checkGLError();
      
        
      setInterval(drawScene, 15);
      setInterval(calcFramerate, 1000);
    }
    
    function calcFramerate() {
      document.getElementById('framerate').innerHTML = "FPS: "+frame_count;
      frame_count = 0;
    }
            
    function canvas_clicked(event) {
      <%=yield :canvas_clicked%>
    }
          
    function mouse_moved(event) {
      // FIXME doesn't account for scroll offsets
      mouse.overCanvas = true;
      mouse.offsetx = mouse.x;
      mouse.offsety = mouse.y;
      mouse.x = event.clientX - $(this).cumulativeOffset()[0]+1;
      mouse.y = event.clientY - $(this).cumulativeOffset()[1]+1;
      if (mouse.offsetx)
        mouse.diffx = mouse.x - mouse.offsetx;
      if (mouse.offsety)
        mouse.diffy = mouse.y - mouse.offsety;

      if (mouse.down == null) {
        <%=yield :mouse_moved%>
      }
      else
      {
        <%=yield :mouse_dragged%>
      }
    }
          
    function mouse_over(event) {
      <%=yield :mouse_over%>
    }
          
    function mouse_out(event) {
      <%=yield :mouse_out%>
    }
          
    function mouse_down(event) {
      var button = event.which;
      
      mouse.down = mouse.down || {count:0,down:{}};
      button = mouse.down["button"+button] = {at:[mouse.x,mouse.y]};
      
      <%=yield :mouse_pressed%>
    }
          
    function mouse_up(event) {
      if (mouse.down)
      {
        mouse.down.count--;
        if (mouse.down.count <= 0)
          mouse.down = null;
      }
      
      <%=yield :mouse_released%>
    }
  </script>
</head>
  <body onload="webGLStart();">
    <div id="framerate" style="float:left;width:100px;">Calculating...</div>
    <div style="clear:right;"><a href="#" onclick='$("logger").toggle();return false;'>See Log</a></div>
    <div style='clear:both;white-space:pre;font-family:monospace;height:10em;overflow:auto;display:none;' id="logger">
    </div>
    <canvas id="canvas" style="border: none;" width="800" height="500"></canvas>
    <%=yield%>
  </body>
</html>
